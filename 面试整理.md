### 04.07
有两场面试，一个是上海 ai lab（50/100），一个是上海一个小厂（80/100）
1. HTTP协议中的流式传输是用什么协议实现的
- 无论是传统的 HTTP 请求-响应，还是流式传输，本质上都是基于 TCP 这个传输层协议完成的数据传递。
- HTTP/2 流（stream）机制
HTTP/2 引入了多路复用，多个逻辑 stream 复用一个 TCP 连接，每个 stream 可独立传输。
底层依旧是 TCP，但数据以帧（frame）形式传输，更适合流式场景（比如 gRPC）。

2. 详细介绍一个aigc平台上传一个文件到返回用户信息整个过程和用到的中间件
用户上传的文件通过网关接入（鉴权JWT、限流、路由转发Trafik），先存入对象存储(一般都是用云存储)，通过消息队列异步(kafka、rabbitmq)通知AIGC服务（GPU节点）处理结果，处理后的结果存入Redis/MySQL，最后前端轮询或推送结果展示给用户。

3. 固定窗口之间的区别
- 固定窗口
将时间划分为一个个固定的区间（如每 1 秒一个窗口）。
每个窗口单独统计请求数量，达到阈值就拒绝后续请求。
- 滑动窗口
不是按固定时间段，而是按当前时间为参考点不断滑动窗口。
将一个大窗口划分成多个小窗口（如 1 秒划分为 10 个 100ms 的小格），实时更新统计。
4. 防止缓存击穿是怎么实现的
- 把每一个请求抽象为一个Call，相同的key请求用map映射到同一个Call
- 第一个key请求，查询map没有，新建一个Call存入map，并且使用wg.Add(1)
- 剩余的同一个key的请求查询map有对应的Call，但是被wg.Wait()阻塞，直到第一个key的请求把数据库中的数据更新到缓存并且使用wg.Done()，然后剩余的请求才能拿到缓存中数据
- 生成新的Call和销毁一个Call的过程需要用Mutex加锁

5. 仿GroupCache的流程

```
Group.Get(key)
    ├── 本地缓存命中？ → 是 → 返回
    │
    └── 否 → load(key)
            ├── 找到远程节点→ 是本身吗？ 否 → getFromPeer → 成功返回
            │                          ↓ 是 → GetLocally
            └── getLocally
                  ├── 调用 Getter 拿原始数据
                  └── 缓存到 mainCache
            ↓
         返回结果
```

6. HTTP缓存的实现方式
- 每个网络端口抽象为一个peer（节点）
- 用三个网络端口开启三个进程，每个进程都有自己的mainCache和peers，这个peers里面就包括三个端口
- 假设第一个进程对应的端口中的mainCache没有缓存数据，就利用一致性哈希选择一个peer节点，然后向这个peer节点发送HTTP请求，这个peer节点对应的进程的mainCache中如果也没有，但是再利用一致性哈希只能找到自己所以就从SlowDB中加载到自己的mainCache并返回数据
- 下一次访问同一个key，还是第一个节点没有缓存数据，用一致性哈希选择节点，从那个节点的mainCache中取数据

7. Redis常见数据类型与使用
# Redis 数据类型与典型应用场景

| 数据类型       | 典型应用场景                                                                 |
|----------------|------------------------------------------------------------------------------|
| **String**      | - 缓存热点数据（用户 session、页面片段）<br>- 计数器（浏览量、自增 ID）<br>- 存储验证码、token、配置项 |
| **List**        | - 简易消息队列（任务推送、异步处理）<br>- 时间线/评论系统（按时间顺序）<br>- 日志系统收集 |
| **Hash**        | - 用户信息缓存（user:id -> name, email）<br>- 商品或文章详情结构化存储<br>- 用户购物车（商品 + 数量） |
| **Set**         | - 标签系统（如文章标签、兴趣分类）<br>- 社交系统好友/关注关系<br>- 签到、活跃用户去重 |
| **Sorted Set**  | - 排行榜系统（积分、热度）<br>- 内容推荐排序（点击量、活跃度）<br>- 延迟任务队列（score=时间戳） |
| **HyperLogLog** | - UV 统计（独立访客）<br>- 活动参与人数估算<br>- 大规模数据去重统计 |
| **Bitmap**      | - 用户签到记录（按天位标记）<br>- 是否看过某内容（位表示状态）<br>- 用户权限或在线状态标记 |
| **Stream**      | - 高级消息队列（支持 ack、持久化）<br>- 日志流系统<br>- 实时聊天、IoT 数据流 |
