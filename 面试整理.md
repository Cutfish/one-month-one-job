### 04.07
有两场面试，一个是上海 ai lab（50/100），一个是上海一个小厂（80/100）
1. HTTP协议中的流式传输是用什么协议实现的
- 无论是传统的 HTTP 请求-响应，还是流式传输，本质上都是基于 TCP 这个传输层协议完成的数据传递。
- HTTP/2 流（stream）机制
HTTP/2 引入了多路复用，多个逻辑 stream 复用一个 TCP 连接，每个 stream 可独立传输。
底层依旧是 TCP，但数据以帧（frame）形式传输，更适合流式场景（比如 gRPC）。

2. 详细介绍一个aigc平台上传一个文件到返回用户信息整个过程和用到的中间件
用户上传的文件通过网关接入（鉴权JWT、限流、路由转发Trafik），先存入对象存储(一般都是用云存储)，通过消息队列异步(kafka、rabbitmq)通知AIGC服务（GPU节点）处理结果，处理后的结果存入Redis/MySQL，最后前端轮询或推送结果展示给用户。

3. 固定窗口之间的区别
- 固定窗口
将时间划分为一个个固定的区间（如每 1 秒一个窗口）。
每个窗口单独统计请求数量，达到阈值就拒绝后续请求。
- 滑动窗口
不是按固定时间段，而是按当前时间为参考点不断滑动窗口。
将一个大窗口划分成多个小窗口（如 1 秒划分为 10 个 100ms 的小格），实时更新统计。
4. 防止缓存击穿是怎么实现的
- 把每一个请求抽象为一个Call，相同的key请求用map映射到同一个Call
- 第一个key请求，查询map没有，新建一个Call存入map，并且使用wg.Add(1)
- 剩余的同一个key的请求查询map有对应的Call，但是被wg.Wait()阻塞，直到第一个key的请求把数据库中的数据更新到缓存并且使用wg.Done()，然后剩余的请求才能拿到缓存中数据
- 生成新的Call和销毁一个Call的过程需要用Mutex加锁

5. 仿GroupCache的流程

```
Group.Get(key)
    ├── 本地缓存命中？ → 是 → 返回
    │
    └── 否 → load(key)
            ├── 找到远程节点→ 是本身吗？ 否 → getFromPeer → 成功返回
            │                          ↓ 是 → GetLocally
            └── getLocally
                  ├── 调用 Getter 拿原始数据
                  └── 缓存到 mainCache
            ↓
         返回结果
```

6. HTTP缓存的实现方式
- 每个网络端口抽象为一个peer（节点）
- 用三个网络端口开启三个进程，每个进程都有自己的mainCache和peers，这个peers里面就包括三个端口
- 假设第一个进程对应的端口中的mainCache没有缓存数据，就利用一致性哈希选择一个peer节点，然后向这个peer节点发送HTTP请求，这个peer节点对应的进程的mainCache中如果也没有，但是再利用一致性哈希只能找到自己所以就从SlowDB中加载到自己的mainCache并返回数据
- 下一次访问同一个key，还是第一个节点没有缓存数据，用一致性哈希选择节点，从那个节点的mainCache中取数据

7. Redis常见数据类型与使用
# Redis 数据类型与典型应用场景

| 数据类型       | 典型应用场景                                                                 |
|----------------|------------------------------------------------------------------------------|
| **String**      | - 缓存热点数据（用户 session、页面片段）<br>- 计数器（浏览量、自增 ID）<br>- 存储验证码、token、配置项 |
| **List**        | - 简易消息队列（任务推送、异步处理）<br>- 时间线/评论系统（按时间顺序）<br>- 日志系统收集 |
| **Hash**        | - 用户信息缓存（user:id -> name, email）<br>- 商品或文章详情结构化存储<br>- 用户购物车（商品 + 数量） |
| **Set**         | - 标签系统（如文章标签、兴趣分类）<br>- 社交系统好友/关注关系<br>- 签到、活跃用户去重 |
| **Sorted Set**  | - 排行榜系统（积分、热度）<br>- 内容推荐排序（点击量、活跃度）<br>- 延迟任务队列（score=时间戳） |
| **HyperLogLog** | - UV 统计（独立访客）<br>- 活动参与人数估算<br>- 大规模数据去重统计 |
| **Bitmap**      | - 用户签到记录（按天位标记）<br>- 是否看过某内容（位表示状态）<br>- 用户权限或在线状态标记 |
| **Stream**      | - 高级消息队列（支持 ack、持久化）<br>- 日志流系统<br>- 实时聊天、IoT 数据流 |

### 04-15
南京一个小厂（最快的一集，半小时不到）
1. goroutine底层，在golang中是什么地位。一个函数的多个G更倾向于分配到多个P还是一个P上（从全局队列拿G有没有什么倾向）
goroutine的底层本质 是一个非常轻量级的用户态线程，其核心是 Go 运行时（runtime）自己维护的调度系统。在底层实现中，goroutine 被表示为一个结构体 G，由 Go 的 GMP 模型管理和调度。
- goroutine的id
- 保存上下文：寄存器信息、程序计数器（PC）、栈指针（SP）等，支持协程切换。
- 状态管理：每个 G 都有状态，如 _Grunnable, _Gwaiting, _Grunning。

当前 P 是你创建 G 的“发起者”，直接放入它的本地队列效率最高，不需要加锁（相比全局队列需要锁），也避免了繁琐的上下文切换。
2. 以前的是GM现在是GMP，P起到什么作用 

| 功能项           | 说明                                                                 |
|------------------|----------------------------------------------------------------------|
| 本地 G 队列（runq） | 每个 P 拥有自己的 goroutine 队列，减少 G 的全局调度冲突。              |
| 调度上下文         | P 保存运行时的调度状态、分配的资源（比如内存、缓存等）。                 |
| M 和 G 的粘合剂     | M 只有在绑定 P 的情况下，才能执行 G。没有 P，M 无法调度。                 |
| 调度逻辑的载体      | Go 的调度循环 schedule() 是以 P 为中心进行的：找 G -> 找空闲 M -> 执行。 |
3. defer原理
📦 一、编译期原理
- 在 编译阶段，defer 并不是立即生成调用指令，而是将其作为一个特殊的结构记录下来，最终统一在函数返回前处理。
- 每个函数在编译时会有一个 defer 栈（链表）。
- 遇到 defer，会将其封装为一个结构体 deferproc，加入当前函数的 defer 链表中。
- 编译器在函数 return 前会插入一段代码，调用这些 defer 的函数。
🏃‍♂️ 二、运行期原理
- 在函数运行过程中：
- 执行到 defer 语句时：
- 会计算 defer 的函数参数值，并将函数指针 + 参数一起封装为一个结构体（称为 _defer）。
- 把这个 _defer 放入当前 goroutine 的 defer 链表中。
- 函数退出时（正常 return 或 panic）：
- 会按**先进后出（LIFO）** 的顺序依次调用 _defer 链表中的函数。
4. HTTP和RPC区别
- HTTP是一个应用层协议，RPC是远程过程调用，只是一种函数（或方法）调用方式，与之对应的是本地调用，所谓的RPC协议其实只是基于TCP、UDP甚至是HTTP2改造之后的协议
- HTTP有很多适应浏览器的冗余字段，这些事内部服务用不到的，RPC可以摒弃很多HTTP Header中的字段（比如浏览器的各种行为）
- HTTP数据格式是JSON/XML（文本格式），但是RPC是Protobuf、Thrift（二进制格式），后者传输效率更高
- HTTP更适用于Web应用、前后端交互，而RPC更适用于微服务、分布式系内部通信。

RPC比HTTP出现的早，主要就是为了解决远程函数调用的问题。
一个单体服务内部的各个模块之间可以直接用本地函数（方法）调用，但是一个分布式微服务的系统内部各个模块的都是独立的服务，他们可能存储在不同的主机或者不同的容器中，那么他们就只能用远程函数（方法）调用
5. 介绍一下MYSQL的索引、索引失效？
- 索引是数据库中用于加速查询效率的一种数据结构，就像书本的目录，可以快速定位数据而不用全表扫描。
- 加速查询、范围扫描、排序
- 常见的有主键索引、唯一索引、普通索引、组合索引
- InnoDB默认使用b+树
- 注意建立索引的时机和索引的使用
- Explain查询是否命中索引
6. docker编写dockerfile流程，RUN命令写一行还是多行好
- 指定基础镜像（FROM）、设置环境变量（ENV）、安装依赖（RUN）拷贝文件（COPY、ADD）、运行命令（CMD）
- RUN：在镜像构建阶段执行命令，并将执行结果提交为新的一层镜像。

| 写法风格             | 优点                                           | 缺点                                                       |
|----------------------|------------------------------------------------|------------------------------------------------------------|
| 一行一个 RUN         | 清晰易读、便于调试                             | 每一条 RUN 会生成一个中间镜像层，最终镜像变大，构建变慢   |
| 多条命令合并一行 RUN | 减少镜像层数，镜像更小，构建更快               | 可读性差，调试困难，改动后容易导致缓存失效                 |

7. 僵尸进程是什么，wait()/waitpid()有什么用？原理是？
- 子进程已经退出，但其父进程尚未调用 wait 或 waitpid 回收它的退出状态信息，导致其在系统中仍占据一个进程表项的特殊进程。
- wait()	阻塞等待任意一个子进程结束，并回收它的资源。
- waitpid()	可以精确指定等待某个子进程结束；支持非阻塞模式，更灵活。
- 子进程执行完毕后调用 exit()，进入退出状态。内核不会立即释放该进程的 PCB（进程控制块），而是将其标记为 Z（僵尸进程），并记录其退出状态。内核给父进程发送 SIGCHLD 信号，通知它有子进程退出。
8. 一个表里面只有姓名、性别和年龄三个字段，怎么设置索引比较好

| 字段   | 是否建议建索引 | 理由                         |
|--------|----------------|------------------------------|
| name   | ✅ 是           | 查询常用字段，区分度高        |
| age    | ✅ 是           | 可用于范围查询               |
| gender | ❌ 否           | 只有两种值，区分度低，索引不生效 |
name和age也可以建立组合索引（注意顺序）
9. ceph的存储和使用，存大文件好还是小文件好，存静态文件好还是动态文件好
👉 RGW（前台）接收你上传的文件。
👉 RGW 把 example.txt 切成几个“页”大小的小块（对象）。
👉 RGW 查询 MON（管理员）：我要存这些小块，去哪放？
👉 MON 看当前 OSD 状态，结合 CRUSH 算法，告诉 RGW：
小块1 放 OSD3、OSD5、OSD7（副本）
小块2 放 OSD2、OSD4、OSD6
👉 RGW 把小块分别发到这些 OSD 存起来。
👉 RGW 在 omap 中记录：你这个 example.txt 是由哪几个小块组成的，每块的名字、大小等。
✅ 上传完成！

| 文件类型 | 是否适合使用 Ceph | 理由 |
|----------|-------------------|------|
| 大文件（如视频、备份镜像） | ✅ 适合 | 更容易划分为对象，元数据压力小，系统吞吐高 |
| 小文件（如图片、日志、文档） | ❌ 不太适合（除非优化） | 元数据数量庞大，造成性能瓶颈，建议合并或使用 CephFS |

---

| 文件类型 | 是否适合使用 Ceph | 理由 |
|----------|-------------------|------|
| 静态文件（如图片、音频、HTML、备份等） | ✅ 非常适合 | 读取频繁、写入少，适合对象存储特性，可高效缓存 |
| 动态文件（如频繁更新的数据库文件） | ❌ 不适合 | 高频更新会造成较高延迟，Ceph 不擅长高频小写入 |

南京全职公司电话面试（一个月两千多，没有住宿）：
1. 两个项目有没有遇到什么问题怎么解决的
- 第一个说了K8s没有部署成功
2. 除了protobuf优化节点数据序列化，还有没有什么方法
Cap’n Proto（Captain proto）
特点：比 Protobuf 更快、零拷贝、跨语言
优点：支持直接访问内存结构（不需要 decode）。高吞吐、低延迟
