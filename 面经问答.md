### 我现在有1万个问答请求，但服务器只能同时容纳1000个请求，你怎么做
1. 限流（Rate Limiting）
防止服务器过载，确保核心服务稳定
使用 令牌桶（Token Bucket） 或 漏桶（Leaky Bucket） 算法，限制 QPS（每秒请求数）。
如果超出并发上限, 返回 429（请求过多），让客户端稍后重试。
可以使用 Nginx、Traefik 或 API Gateway 来做限流。
2. 请求排队（Message Queue）
避免请求直接被拒绝，保证请求最终被处理
使用 RabbitMQ / Kafka / Redis 等消息队列，将请求存入队列，后端逐步处理。
服务器空闲时从队列中拉取请求，避免因短时间内流量过大导致崩溃。
3. 负载均衡（Load Balancing）
扩展服务器能力，提高并发吞吐量
部署多个服务器实例，使用 Nginx / Traefik / Kubernetes 进行负载均衡。
将 1 台服务器的 1000 并发扩展到多台服务器，如 10 台服务器可支持 1 万并发。
4. 降级处理（Graceful Degradation）
保证核心功能可用，非核心功能暂时禁用
高峰期时，优先处理重要请求，低优先级请求返回默认值或缓存结果。
可缓存部分响应，减少数据库和计算压力，如 Redis / CDN 预缓存常用数据。

### 传入后端的问答数据，有不同的格式，如何根据格式进行分类存储，并且要保证数据的有序性。
格式识别：判断 JSON / XML / 纯文本
解析转换：XML转换为json或者统一转换为QA结构体
分类存储：存入 MySQL / Redis / MongoDB/ 消息队列
保证顺序：使用时间戳、ID进行排序


### RabbitMQ对比Kafka
消息模型	队列模型（点对点、发布/订阅）	日志模型（消息分区、顺序消费）
吞吐量	中等（万级 QPS）	极高（百万级 QPS）
消息顺序	支持严格顺序	分区内有序，全局无序
消息持久化	基于磁盘存储，但会定期删除消费过的消息	日志式存储，消息保留一定时间（默认 7 天）
可靠性	支持消息确认机制，保证投递成功	高吞吐但可能丢消息（可配合 acks=all 方案提高可靠性）
事务支持	支持事务消息	默认不支持事务（只能用幂等性方式处理）
消息延迟	低（ms 级），适合实时性要求高的场景	默认批量处理，延迟较高（秒级）
扩展性	扩展性一般，队列存在性能瓶颈	天然分布式，横向扩展性强
应用场景	金融、订单系统、事务处理、低延迟场景	日志处理、流式计算、实时数据分析、大数据

### 哈希索引
✅ Memory 引擎 默认使用哈希索引
✅ InnoDB 主要使用 B+ 树索引，但有 自适应哈希索引（AHI）（=、in才触发）
✅ 哈希索引适用于 等值查询，但不支持 范围查询
✅ AHI 由 InnoDB 自动管理，如果影响性能可以手动关闭

### 秒杀库存超卖
1. Redis 分布式锁 + Lua
秒杀开始前，将商品库存存入 Redis。
购买时，先用 Redis SETNX 加锁，确保同一时间只有一个线程在修改库存。
用 Lua 脚本原子性地判断库存并减少库存，避免并发问题。
2. 消息队列（MQ）
用户请求先写入消息队列，队列按顺序消费。
后台任务逐步减少库存，避免数据库压力过大。